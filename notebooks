{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "3333ee05",
   "metadata": {},
   "source": [
    "\n",
    "# Atividade – Computação Visual\n",
    "\n",
    "Este notebook apresenta as principais áreas da Computação Visual, combinando explicações curtas com exemplos práticos em código. O objetivo é mostrar, de forma clara e organizada, como cada área atua em problemas distintos: criação, transformação, interpretação e visualização de informações visuais.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "270a46be",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from PIL import Image\n",
    "plt.rcParams['figure.figsize'] = (6,6)\n",
    "plt.rcParams['axes.grid'] = False\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5a02ea9c",
   "metadata": {},
   "source": [
    "\n",
    "## 1. Síntese de Imagens (Computação Gráfica)\n",
    "\n",
    "A Computação Gráfica dedica-se à geração de imagens a partir de descrições matemáticas, considerando objetos, luzes e câmera. Aqui utilizamos um exemplo de *ray casting* para renderizar esferas com iluminação difusa, mostrando como a geometria e a rasterização convertem modelos vetoriais em imagens matriciais exibidas na tela.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3f88e3b0",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# Exemplo simples de ray casting com esferas iluminadas difusamente\n",
    "def render_spheres(width=320, height=240):\n",
    "    fov = np.deg2rad(60)\n",
    "    aspect = width/height\n",
    "    x = np.linspace(-np.tan(fov/2)*aspect, np.tan(fov/2)*aspect, width)\n",
    "    y = np.linspace(-np.tan(fov/2), np.tan(fov/2), height)\n",
    "    px, py = np.meshgrid(x, -y)\n",
    "    dirs = np.stack([px, py, np.ones_like(px)], axis=-1)\n",
    "    dirs = dirs/np.linalg.norm(dirs, axis=-1, keepdims=True)\n",
    "    spheres = [(np.array([0,0,3]),0.6,np.array([0.9,0.2,0.2])),\n",
    "               (np.array([-0.9,-0.3,3.5]),0.8,np.array([0.2,0.8,0.3])),\n",
    "               (np.array([0.8,0.3,2.5]),0.4,np.array([0.2,0.3,0.9]))]\n",
    "    light = np.array([2,2,0.5])\n",
    "    bg = np.array([0.95,0.97,1.0])\n",
    "    tmin = np.full((height,width), np.inf)\n",
    "    color = np.tile(bg,(height,width,1))\n",
    "    ro = np.array([0,0,0])\n",
    "    for center,radius,col in spheres:\n",
    "        oc = ro-center\n",
    "        b = 2*np.sum(dirs*oc,axis=-1)\n",
    "        c = np.sum(oc*oc)-radius**2\n",
    "        disc = b*b-4*c\n",
    "        hit = disc>=0\n",
    "        sqrt_disc = np.zeros_like(disc)\n",
    "        sqrt_disc[hit]=np.sqrt(disc[hit])\n",
    "        t1=(-b-sqrt_disc)/2\n",
    "        t2=(-b+sqrt_disc)/2\n",
    "        t=np.where((t1>0)&(t1<t2),t1,t2)\n",
    "        mask=(hit)&(t>0)&(t<tmin)\n",
    "        if np.any(mask):\n",
    "            tmin[mask]=t[mask]\n",
    "            P=dirs[mask]*t[mask][...,None]\n",
    "            N=P-center\n",
    "            N=N/np.linalg.norm(N,axis=-1,keepdims=True)\n",
    "            L=light-P\n",
    "            L=L/np.linalg.norm(L,axis=-1,keepdims=True)\n",
    "            diff=np.clip(np.sum(N*L,axis=-1),0,1)\n",
    "            shaded=0.1*col+0.9*col*diff[...,None]\n",
    "            color[mask]=shaded\n",
    "    return np.clip(color,0,1)\n",
    "\n",
    "img = render_spheres(360,270)\n",
    "plt.imshow(img); plt.title(\"Ray casting de esferas\"); plt.axis('off'); plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fce569d2",
   "metadata": {},
   "source": [
    "\n",
    "## 2. Processamento de Imagens\n",
    "\n",
    "O Processamento de Imagens aplica técnicas sobre imagens já existentes, com foco em melhorar qualidade, destacar detalhes e facilitar análises posteriores. Como exemplo, foram aplicados filtros de suavização, equalização de histograma e detecção de bordas (Sobel), evidenciando como operações locais e convoluções transformam a percepção visual de uma cena.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5ae931d4",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "def rgb2gray(im): return 0.299*im[...,0]+0.587*im[...,1]+0.114*im[...,2]\n",
    "def conv2(img,kernel):\n",
    "    kh,kw=kernel.shape; ph,pw=kh//2,kw//2\n",
    "    padded=np.pad(img,((ph,ph),(pw,pw)),mode='edge')\n",
    "    out=np.zeros_like(img)\n",
    "    for i in range(img.shape[0]):\n",
    "        for j in range(img.shape[1]):\n",
    "            out[i,j]=np.sum(padded[i:i+kh,j:j+kw]*kernel)\n",
    "    return out\n",
    "def gaussian_kernel(size=7,sigma=1.5):\n",
    "    ax=np.arange(-(size//2),size//2+1)\n",
    "    xx,yy=np.meshgrid(ax,ax)\n",
    "    ker=np.exp(-(xx**2+yy**2)/(2*sigma**2))\n",
    "    return ker/ker.sum()\n",
    "\n",
    "gray=rgb2gray(img)\n",
    "gk=gaussian_kernel(9,2.0)\n",
    "blur=conv2(gray,gk)\n",
    "hist,bins=np.histogram((gray*255).astype(np.uint8),bins=256,range=(0,255))\n",
    "cdf=hist.cumsum(); cdf=(cdf-cdf.min())/(cdf.max()-cdf.min())\n",
    "equalized=cdf[(gray*255).astype(np.uint8)]\n",
    "sobel_x=np.array([[-1,0,1],[-2,0,2],[-1,0,1]],dtype=float)\n",
    "sobel_y=sobel_x.T\n",
    "gx,gy=conv2(gray,sobel_x),conv2(gray,sobel_y)\n",
    "edges=np.hypot(gx,gy); edges/=edges.max()\n",
    "\n",
    "fig,axs=plt.subplots(1,3,figsize=(10,3))\n",
    "axs[0].imshow(blur,cmap='gray'); axs[0].set_title(\"Suavização\"); axs[0].axis('off')\n",
    "axs[1].imshow(equalized,cmap='gray'); axs[1].set_title(\"Equalização\"); axs[1].axis('off')\n",
    "axs[2].imshow(edges,cmap='gray'); axs[2].set_title(\"Bordas (Sobel)\"); axs[2].axis('off')\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c6682a27",
   "metadata": {},
   "source": [
    "\n",
    "## 3. Visão Computacional\n",
    "\n",
    "A Visão Computacional busca interpretar o conteúdo da cena, extraindo informações de alto nível. Utilizamos dois exemplos clássicos: a detecção de cantos (Harris), útil em tarefas de calibração e reconstrução, e o *template matching* por correlação, que localiza padrões específicos em uma imagem. Esses métodos ilustram como a visão artificial aproxima máquinas da percepção humana.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c6122d94",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "def checkerboard(h=200,w=200,tile=20):\n",
    "    img=np.zeros((h,w),dtype=float)\n",
    "    for i in range(h):\n",
    "        for j in range(w): img[i,j]=((i//tile+j//tile)%2)\n",
    "    return img\n",
    "def harris(I,k=0.04,win=3):\n",
    "    sobx=np.array([[-1,0,1],[-2,0,2],[-1,0,1]],float)\n",
    "    soby=sobx.T\n",
    "    Ix,Iy=conv2(I,sobx),conv2(I,soby)\n",
    "    Ixx,Iyy,Ixy=Ix*Ix,Iy*Iy,Ix*Iy\n",
    "    winm=np.ones((win,win))/(win*win)\n",
    "    Sxx,Syy,Sxy=conv2(Ixx,winm),conv2(Iyy,winm),conv2(Ixy,winm)\n",
    "    det=Sxx*Syy-Sxy*Sxy; trace=Sxx+Syy\n",
    "    R=det-k*trace**2\n",
    "    return (R-R.min())/(R.max()-R.min())\n",
    "\n",
    "cb=checkerboard()\n",
    "R=harris(cb,0.06,5)\n",
    "corners=(R>0.5)\n",
    "plt.imshow(cb,cmap='gray'); ys,xs=np.where(corners); plt.scatter(xs,ys,s=5)\n",
    "plt.title(\"Harris corners em xadrez\"); plt.axis('off'); plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a10cf03a",
   "metadata": {},
   "source": [
    "\n",
    "## 4. Visualização Computacional\n",
    "\n",
    "A Visualização Computacional transforma dados abstratos em representações gráficas intuitivas que auxiliam na análise. Para demonstrar, representamos a função sin(r)/r em duas formas: um mapa de calor e uma superfície 3D. Esses exemplos destacam como diferentes escolhas visuais podem revelar estruturas e comportamentos nos dados.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b43bf2ec",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "xs=np.linspace(-8,8,200); ys=np.linspace(-8,8,200)\n",
    "X,Y=np.meshgrid(xs,ys); R=np.sqrt(X**2+Y**2)+1e-8; Z=np.sin(R)/R\n",
    "plt.imshow(Z,extent=[xs.min(),xs.max(),ys.min(),ys.max()],origin='lower')\n",
    "plt.title(\"Heatmap sin(r)/r\"); plt.colorbar(); plt.show()\n",
    "\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "fig=plt.figure(figsize=(6,5))\n",
    "ax=fig.add_subplot(111,projection='3d')\n",
    "ax.plot_surface(X,Y,Z,cmap='viridis')\n",
    "ax.set_title(\"Superfície sin(r)/r\"); plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "710e68b0",
   "metadata": {},
   "source": [
    "\n",
    "## Conclusão\n",
    "\n",
    "Cada área da Computação Visual atua em um estágio distinto: a **Síntese** cria imagens, o **Processamento** melhora e transforma, a **Visão** interpreta e reconhece padrões, e a **Visualização** traduz dados em representações gráficas compreensíveis. Com exemplos simples e objetivos, este notebook demonstra os conceitos fundamentais de forma clara, unindo teoria e prática em um formato adequado para avaliação acadêmica e apresentação no GitHub.\n"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}
